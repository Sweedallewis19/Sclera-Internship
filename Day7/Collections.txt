Today, I learned about Iterable, which is a root interface in Java Collections that allows us to loop through elements using a for-each loop. It lets us treat different collections uniformly and makes looping easier.

Iterable<String> names = List.of("Alice", "Bob");
for (String name : names)
    System.out.println(name);

Iterator Interface
I learned that the Iterator interface allows us to traverse a collection manually and remove elements safely during iteration.

List<String> list = new ArrayList<>(List.of("a", "b", "c"));
Iterator<String> it = list.iterator();
while (it.hasNext())
    System.out.println(it.next());

Collection Interface

I learned that the Collection interface is the root of most collection types like sets, lists, and queues. It provides basic operations such as add, remove, and size.

Collection<Integer> numbers = new ArrayList<>();
numbers.add(10);
numbers.remove(10);

List Interface
I learned the List interface represents an ordered collection that allows duplicates and access by index. Common implementations are ArrayList and LinkedList.

List<String> list = new ArrayList<>();
list.add("Mosh");
list.get(0);

Comparator Interface
I learned that the Comparator interface is used to define custom sorting logic. It helps us sort objects based on attributes.

List<Integer> nums = List.of(5, 1, 3);
nums.sort(Comparator.reverseOrder());

Queue Interface
I learned that the Queue interface represents a first-in first-out (FIFO) collection. It is useful for processing tasks in order.

Queue<String> queue = new LinkedList<>();
queue.add("task1");
queue.poll(); // returns and removes

Set Interface
I learned that the Set interface stores unique elements and does not allow duplicates. Common implementations are HashSet and LinkedHashSet.

Set<String> set = new HashSet<>();
set.add("a");
set.add("a"); // duplicate ignored

Hashtable and Map Interface
I learned that a Map stores key-value pairs and does not allow duplicate keys. HashMap and Hashtable are implementations. Hashtable is synchronized and thread-safe, while HashMap is not.

Map<String, Integer> map = new HashMap<>();
map.put("age", 25);
map.get("age");